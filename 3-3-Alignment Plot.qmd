# Alignment Plot

## Calculation

```{r,eval=TRUE}
library(lagci)
data("heart_data")
data("step_data")
result <- lagci::calculate_lagged_correlation(
  x = heart_data$heart,
  y = step_data$step,
  time1 = heart_data$time,
  time2 = step_data$time,
  time_tol = 0.5,
  step = 1/60,
  align_method = "linear",
  cor_method = "spearman"
)
```

## Alignment Plot

Here is an example plot:

This call draws an alignment view of the two series in `result` at the **peak lag** (`which = "max"`), coloring the x-series blue and the y-series red (`x_color`, `y_color`) with axis labels set by `x_name = "x"` and `y_name = "y"`.

It limits the plotted **x-values** to the numeric range `c(1, 100000)` (`x_limit`), plots **points** for matched samples (`add_point = TRUE`) with sizes controlled by `x_point_size` and `y_point_size`, and renders any **unmatched** observations with a tiny marker (`non_matched_point_size = 0.1`) so they’re visible but unobtrusive.

With `integrated = FALSE` the two time series are shown on separate tracks rather than overlaid; `add_connect_line = FALSE` suppresses segment lines between matched pairs (turn this on to emphasize pairings).

Finally, `time_gap = 12` spaces major time ticks about every 12 hours, which helps readability over long windows; if the figure looks cramped, either increase `time_gap`, reduce the point sizes, or drop `x_limit` to let the scales auto-fit, and if you want a direct overlay switch to `integrated = TRUE`.

```{r,eval=TRUE}
lagged_alignment_plot(object = result,
                      x_color = "blue",
                      y_color = "red",
                      x_name = "x",
                      y_name = "y",
                      which = "max",
                      x_limit = c(1,100000),
                      non_matched_point_size = 0.1,
                      y_point_size = 1,
                      x_point_size = 1,
                      integrated = FALSE,
                      add_connect_line = FALSE,
                      add_point = TRUE,
                      time_gap = 12)
```

### which

```{r,eval=TRUE}
p_global <- lagged_alignment_plot(result, which = "global", add_point = TRUE,x_limit = c(2000,50000),)
p_max    <- lagged_alignment_plot(result, which = "max",    add_point = TRUE,x_limit = c(2000,50000),)
p_global; p_max
```

### x_limit

```{r,eval=TRUE}
p_limit_1 <- lagged_alignment_plot(result, x_limit = c(1, 5000),time_gap = 1)
p_limit_2  <- lagged_alignment_plot(result, x_limit = c(1, 10000),time_gap = 1)
p_limit_3  <- lagged_alignment_plot(result, x_limit = c(5000, 50000),time_gap = 12)
p_limit_1; p_limit_2; p_limit_3
```

### point

These two calls produce the same alignment view except for whether **matched pairs are drawn as points**.

`p_points` enables `add_point = TRUE`, so matched x–y samples appear as dots (sizes set by `x_point_size` and `y_point_size`), while unmatched observations are shown very small via `non_matched_point_size = 0.1`;

this is useful to judge how dense and well-aligned the pairings are. `p_points_no` switches `add_point = FALSE`, hiding those pairing dots so you can focus on the aligned trajectories without point clutter.

In both, `x_limit = c(1, 10000)` restricts the plotted range of the x-series (handy for clipping extreme values). Print both objects (`p_points; p_points_no`) to compare clarity; if overplotting remains heavy, shrink point sizes or widen the limits, and if you want an overlay instead of separate tracks, set `integrated = TRUE`.

```{r,eval=TRUE}
p_points <- lagged_alignment_plot(result, 
                                        add_point = TRUE,
                                        x_limit = c(1, 10000),
                                        x_point_size = 1,
                                        y_point_size = 1, 
                                        non_matched_point_size = 0.1)

p_points_no   <- lagged_alignment_plot(result, 
                                        add_point = FALSE,
                                        x_limit = c(1, 10000),
                                        x_point_size = 1,
                                        y_point_size = 1, 
                                        non_matched_point_size = 0.1)

p_points; p_points_no
```
